<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>수정체(조절) 시뮬레이터</title>
  <style>
    :root{--bg:#0b1020;--panel:#10192a;--text:#e6eefc;--muted:#9fb5d1;--accent:#6ee7ff;--accent2:#fcae7b}
    *{box-sizing:border-box}body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;margin:0}
    .wrap{max-width:900px;margin:0 auto;padding:16px}
    h1{font-size:1.5rem;margin:.2rem 0 .6rem}
    .controls{display:grid;grid-template-columns:1fr;gap:1rem;margin:1rem 0}
    .card{background:var(--panel);border-radius:14px;padding:12px;border:1px solid #1c2a43}
    label{display:flex;justify-content:space-between;align-items:center;font-size:.95rem;margin-bottom:.35rem;color:var(--muted)}
    .hint{font-size:.8rem;color:var(--muted)}
    input[type=range]{width:100%}
    .pill{display:flex;gap:8px;justify-content:space-between;font-size:.85rem;color:var(--muted)}
    canvas{width:100%;height:auto;background:var(--panel);border-radius:14px;border:1px solid #1c2a43}
    .status{margin:.6rem 0;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>수정체(조절) 시뮬레이터</h1>
    <p class="hint">두 가지 만 조절합니다: <b>물체-눈 거리</b>와 <b>수정체 두께</b>(얇음↔두꺼움). 얇을수록 초점거리 f가 길어지고, 두꺼울수록 짧아집니다. 얇은렌즈 공식 <b>1/f = 1/do + 1/di</b>.</p>

    <div class="controls">
      <div class="card">
        <label>물체 거리 do <span><b id="doLabel">40.0</b> cm</span></label>
        <input type="range" id="doRange" min="50" max="2000" step="10" value="400">
        <div class="hint">가까워질수록(작은 값) 더 두꺼운 수정체가 필요합니다.</div>
      </div>
      <div class="card">
        <label>수정체 두께 <span>얇음 ↔ 두꺼움</span></label>
        <div class="pill"><span>얇음</span><span>두꺼움</span></div>
        <input type="range" id="thickRange" min="0" max="100" step="1" value="40" aria-label="수정체 두께">
        <div class="hint">내부적으로는 두께를 초점거리 f(25→15mm)로 변환해 계산합니다.</div>
      </div>
    </div>

    <canvas id="cv" width="900" height="420" aria-label="광학 시뮬레이션 캔버스"></canvas>
    <p class="status" id="status"></p>
  </div>

<script>
// --- 고정 파라미터 ---
const retinaDistance = 17;      // 렌즈 중심→망막(mm)
const lensX_base = 120;          // 기본 렌즈 x(mm)
const retinaX_base = lensX_base + 200; // 기본 망막 x(mm)
const H = 420, W = 900;

// --- 상태 ---
let do_mm = 400;   // 물체-렌즈 거리(mm)
let thick = 40;    // 0(얇음) ↔ 100(두꺼움)

// 두께→초점거리(mm) 매핑: 0→25mm, 100→15mm (선형)
function thicknessToF(th){
  const f = 25 - (th/100)*(25-15); // 25→15
  return Math.max(15, Math.min(25, f));
}

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

// --- 가변 뷰포트 스케일링 ---
// 물체가 멀거나 가까워도 "물체~망막" 전 구간이 화면에 들어오도록 X 스케일을 동적으로 조정
function computeViewport(){
  const lensX = lensX_base;
  const retinaX = retinaX_base;
  const objectX = lensX - do_mm;
  const minWorldX = Math.min(objectX, lensX);
  const maxWorldX = retinaX;
  const margin = 30; // px 좌우 여백
  const worldSpan = Math.max(40, maxWorldX - minWorldX);
  const scaleX = (W - 2*margin) / worldSpan; // 동적 가로 스케일
  const toPxX = (mm)=> margin + (mm - minWorldX) * scaleX;
  return { lensX, retinaX, objectX, toPxX, minWorldX, maxWorldX, scaleX };
}

function toPxY(mm){ return H/2 + mm*1.2; } // 세로 스케일은 고정

// 가변 렌즈 형상(두께 시각화): 중심부 허리 두께가 두꺼워질수록 넓게
function drawLensShape(px, th){
  const yTop = 40, yBot = H-40;
  // 두께 계수: 얇음(0)일 때 5px, 두꺼움(100)일 때 20px  → 기존 대비 50% 축소
  const halfW = 5 + (th/100)*15;
  ctx.fillStyle = '#0ea5e9';
  ctx.strokeStyle = '#66d9ef';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(px - halfW, yTop);
  ctx.bezierCurveTo(px - halfW*1.6, H*0.35, px - halfW*1.6, H*0.65, px - halfW, yBot);
  ctx.lineTo(px + halfW, yBot);
  ctx.bezierCurveTo(px + halfW*1.6, H*0.65, px + halfW*1.6, H*0.35, px + halfW, yTop);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#0b1020';
  ctx.fillRect(0,0,W,H);

  // 기준선
  ctx.strokeStyle = '#24324b';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, toPxY(0));
  ctx.lineTo(W, toPxY(0));
  ctx.stroke();

  // 뷰포트 계산 (동적 X 스케일)
  const { lensX, retinaX, objectX, toPxX, scaleX } = computeViewport();

  // 렌즈(수정체) 그리기: 두께에 따라 시각적 폭 변화 (50% 축소 적용)
  drawLensShape(toPxX(lensX), thick);

  // 망막면
  const retinaPxX = toPxX(retinaX);
  ctx.strokeStyle = '#f97316';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(retinaPxX, 20);
  ctx.lineTo(retinaPxX, H-20);
  ctx.stroke();

  // 물체(화살표) — 50% 축소: 높이 60→30mm
  const objBaseX = toPxX(objectX);
  const objectHeight = 30; // 50% 축소
  const objTopY = toPxY(-objectHeight);
  const objBaseY = toPxY(0);
  ctx.strokeStyle = '#34d399';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(objBaseX, objBaseY);
  ctx.lineTo(objBaseX, objTopY);
  ctx.lineTo(objBaseX - 10, objTopY + 15);
  ctx.moveTo(objBaseX, objTopY);
  ctx.lineTo(objBaseX + 10, objTopY + 15);
  ctx.stroke();

  // 굴절 계산
  const f_mm = thicknessToF(thick);
  const inv = 1/f_mm - 1/do_mm;
  const di = inv>0 ? 1/inv : Infinity;
  const focusError = (isFinite(di)?di:retinaDistance) - retinaDistance;

  // 광선 (3개) — 꼭짓점 기준, 객체 높이 축소 반영
  const rayStarts=[-objectHeight, -objectHeight*0.5, -objectHeight*0.2];
  for(const ay of rayStarts){
    const ax = lensX - do_mm;            // 물체 꼭짓점 x (월드)
    const m1 = (0 - ay)/(lensX - ax);    // 렌즈 중앙을 향하는 입사선 근사
    const yAtLens = ay + m1*(lensX-ax);

    const bx=lensX, by=yAtLens;          // 렌즈 통과점 (월드)
    let cx,cy;
    if(isFinite(di)){
      cx = lensX + di;                   // 상 위치 x
      cy = ay * (-di/do_mm);             // 배율 m=-di/do
    }else{ cx = lensX + 420/ (1.2/scaleX); cy = by; } // 화면 밖까지 적당히

    ctx.strokeStyle = '#93c5fd';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(toPxX(ax), toPxY(ay)); ctx.lineTo(toPxX(bx), toPxY(by)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(toPxX(bx), toPxY(by)); ctx.lineTo(toPxX(cx), toPxY(cy)); ctx.stroke();
  }

  // 망막상(흐림 근사)
  const magnification = -(isFinite(di)?di/do_mm:0);
  const imageTopY_mm = -objectHeight*magnification; // 축소 반영
  const blur = Math.min(22, Math.abs(focusError)*0.06* (1 + (thick/100)*0.2));
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.beginPath(); ctx.arc(retinaPxX, toPxY(imageTopY_mm), Math.max(3, blur), 0, Math.PI*2); ctx.fill();

  // 텍스트 상태
  const status = document.getElementById('status');
  status.textContent = `do=${(do_mm/10).toFixed(1)} cm  |  두께 슬라이더=${thick}  |  f≈${thicknessToF(thick).toFixed(1)} mm  |  di=${isFinite(di)?di.toFixed(1):'∞'} mm  |  ${Math.abs(focusError)<0.5?'초점 맞음':(focusError>0?'망막 뒤':'망막 앞')}`;
}

// 이벤트 바인딩
const doEl = document.getElementById('doRange');
const thickEl = document.getElementById('thickRange');

doEl.oninput = (e)=>{ do_mm = parseFloat(e.target.value); document.getElementById('doLabel').textContent = (do_mm/10).toFixed(1); draw(); };
thickEl.oninput = (e)=>{ thick = parseFloat(e.target.value); draw(); };

draw();
</script>
</body>
</html>
